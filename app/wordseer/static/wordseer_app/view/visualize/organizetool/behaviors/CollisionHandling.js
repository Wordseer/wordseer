/* Copyright 2012 Aditi Muralidharan. See the file "LICENSE" for the full license governing this code. */Ext.define('WordSeer.view.visualize.organizetool.behaviors.CollisionHandling', {    alternateClassName: ['CollisionHandling'],         statics: {                   /*             handle collision using bounding boxes. Maybe break this up into smaller functions             -the object we are handling collisions for will be known as "current object" or "container"             -the other objects on the foreground will be known as "alien objects"                         Cases handled                       -default: the alien object is moved a set distance away from the the current object               -group: if the objects are inside a group, no collisions are handled               -this is where objects get assigned parents                              Arguments                   object- the current object                   svg- the svg canvas on which collisions are being checked                                  sorry about the mess.          */        handleCollisions:function(object, svg, hovering) {                          //find out what object it is            var type = object.getAttribute("type");                        var group = object.id;            var mygroup = svg.selectAll("#" + group);                          //get the container, this will be used as the bounding box.            var container = mygroup.select( function() {              if(this.getAttribute("use") === "container") {                  return this;              }              else {                  return null;              }                          });                        container = D3Helper.getElFromSel(container);                          //find the 4 corners of the bounding box            var my_left = D3Helper.getTransformX(container);            var my_right = my_left + D3Helper.getWidth(type, container);            var my_up = D3Helper.getTransformY(container);            var my_down = my_up + D3Helper.getHeight(type, container);                          //find all objects which lie inside the 4 corners            var alien = svg.selectAll(".foreground")                .select(function(d) {                                    if(this.getAttribute("use") === "container" && this.getAttribute("id") !== container.getAttribute("id")) {                        return this;                    }                    else {                        return null;                    }                 });                               //for each alien, check for a collision             var collision = alien.each(function(d) {                            var al_type = this.getAttribute("type");                var al_id = this.id;                                                          //get the alien's 4 corners                                var al_left = D3Helper.getTransformX(this);                var al_right = al_left + D3Helper.getWidth(al_type, this);                var al_up = D3Helper.getTransformY(this);                var al_down = al_up + D3Helper.getHeight(al_type, this);                              //checks for a collision on the right side of the current object                var col_rightSide = (al_left >= my_left && al_left <= my_right);                                  //checks for a collision on the left side of the current object                var col_leftSide = (al_right > my_left && al_right < my_right);                                  //checks for a collision where the current object is inside the alien horizontally                var col_horizBig = (al_left < my_left && al_right > my_right);                                  //checks for a collision where the alien is inside the current object horizontally                var col_horizSmall = (my_left < al_left && my_right > al_right);                                  //checks for a collision on the upper half of the current object                var col_upSide = (al_down >= my_up && al_down <= my_down);                                    //checks for a collision on the lower half of the current object                var col_downSide = (al_up > my_up && al_up < my_down);                                  //checks for a collision where the alien is inside the current object vertically                var col_vertBig = (al_up < my_up && al_down > my_down);                                  //checks for a collision where the alien is inside the current object vertically                var col_vertSmall = (my_up < al_up && my_down > al_down);                                    //if any possible collision happened                if ( ( (col_rightSide) || (col_leftSide) || (col_horizBig) ) && ( (col_upSide) || (col_downSide) || (col_vertBig) ) ) {                                    if(al_type === "annotation" && type === "annotation") {                        return;                    }                                      //if annotation, add to group                    if( al_type === "annotation"){//                        console.log("2");                                                        //if container is higher z than current parent                        var al_parent_id = this.getAttribute("parent");                                                if (al_parent_id !== "none"){                            var al_parent = svg.selectAll("#" + al_parent_id).select(function(d){                                if(this.getAttribute("use") === "container") {                                    return this;                                }                                                                else{                                    return null;                                }                            });                                                        var al_parent = D3Helper.getElFromSel(al_parent);                                                        if(parseInt(container.getAttribute("layer")) < parseInt(al_parent.getAttribute("layer") ) ) {                                d3.select(this)                                    .attr("parent", group);                                                        }                                                        if(parseInt(container.getAttribute("layer")) === parseInt(al_parent.getAttribute("layer") ) ) {                                if(parseInt(container.getAttribute("z")) > parseInt(al_parent.getAttribute("z") ) ) {                                    d3.select(this)                                        .attr("parent", group);                                }                            }                        }                                                else {                            d3.select(this)                                .attr("parent", group);                        }                        return;                    }                                        if (type === "annotation"){                                                //if container is higher z than current parent                        var cont_parent_id = container.getAttribute("parent");                                                if (cont_parent_id !== "none"){                            var cont_parent = svg.selectAll("#" + cont_parent_id).select(function(d){                                if(this.getAttribute("use") === "container") {                                    return this;                                }                                                                else{                                    return null;                                }                            });                                                        var cont_parent = D3Helper.getElFromSel(cont_parent);                                                        if( !CollisionHandling.collided(cont_parent, container)) {                                d3.select(container)                                    .attr("parent", al_id);                            }                                                        if(parseInt(this.getAttribute("layer")) < parseInt(cont_parent.getAttribute("layer") )){                                d3.select(container)                                    .attr("parent", al_id);                                                        }                                                        if(parseInt(this.getAttribute("layer")) === parseInt(cont_parent.getAttribute("layer") ) ){                                                        if(parseInt(this.getAttribute("z")) > parseInt(cont_parent.getAttribute("z") ) ) {                                    d3.select(container)                                        .attr("parent", al_id);                                }                               }                                                                        }                                            else{                            d3.select(container)                                .attr("parent", al_id);                        }                                                return;                    }                                      //this is how far to move the alien so it is outside of the current object                    var move_x = 0;                    var move_y = 0;                                          //move the alien object to the right of the current object                    if(col_rightSide) {                         move_x = (my_right - al_left) + 20;                     }                                          //move the alien object to the left of the current object                    else if(col_leftSide) {                         move_x = (my_left - al_right) - 20;                     }                      //move the alien object to the top of the current object                    if(col_upSide) {                         move_y = (my_up - al_down) - 20;                     }                                          //move the alien object to the bottom of the current object                    else if(col_downSide) {                        move_y = (my_down - al_up) + 20;                     }                                          //never move diagonally...only move the way the causes the least amount of movement                    if ( Math.abs(move_y) >= Math.abs(move_x) && move_x !== 0) {                        move_y = 0;                    }                                          else if ( Math.abs(move_x) >= Math.abs(move_y) && move_y !== 0) {                        move_x = 0;                    }                                          //if the current object falls inside the alien object                          if(col_vertSmall && col_horizSmall) {                        if (type === "group" || al_type === "annotation") {                                                      //add the alien object to the group if it has no group                            if( this.getAttribute("parent") === "none") {                                                          d3.select(this)                                    .attr("parent", group);                                                                    CollisionHandling.handleCollisions(this, svg, false);                                return;                            }                                                          //make sure the alien object gets added to the smallest subgroup based on z index                            else {                                                                                          //select the parent from the foreground                                var parentId = this.getAttribute("parent");                                var myParent = svg.selectAll(".foreground").select( function(d) {                                                                        if( this.id === parentId && this.getAttribute("use") === "container") {                                         return this;                                    }                                                                        else {                                        return null;                                    }                                });                                                                myParent = D3Helper.getElFromSel(myParent);                                                                                                                         //the z index comparison...alien object should be added to the grouop with the largest z index                                if ( myParent !== null && parseInt(container.getAttribute("z")) > parseInt(myParent.getAttribute("z")) ) {                                    d3.select(this)                                        .attr("parent", group);                                                                                CollisionHandling.handleCollisions(this, svg, false);                                    return;                                }                                                                if (type === "annotation" && al_type !== "group") {                                    d3.select(this)                                        .attr("parent", group);                                    return;                                }                                                            }                                                    }                        }                                          //if the current object falls inside the alien object                    if(col_vertBig && col_horizBig) {                                          if (al_type === "group") {                                                          //add the alien object to the group if it has no group                            if( this.getAttribute("parent") === "none") {                                                          d3.select(container)                                    .attr("parent", this.id);                                return;                            }                                                          //make sure the alien object gets added to the smallest subgroup based on z index                            else {                                                              //select the parent from the foreground                                var parentId = container.getAttribute("parent");                                var myParent = svg.selectAll(".foreground").select( function(d) {                                                                        if( this.id === parentId && this.getAttribute("use") === "container") {                                         return this;                                    }                                                                        else {                                        return null;                                    }                                });                                                                myParent = D3Helper.getElFromSel(myParent);                                                                                      //the z index comparison...alien object should be added to the grouop with the largest z index                                if ( myParent !== null && parseInt(this.getAttribute("z")) > parseInt(myParent.getAttribute("z")) ) {                                    d3.select(container)                                        .attr("parent", this.id);                                    return;                                }                                                                                            }                                                    }                                                }                                          //handling collisions inside a group                                            if( ( container.getAttribute("parent") === this.getAttribute("parent") ) && this.getAttribute("parent") !== "none" ){                            //get the group box                              //get the container, this will be used as the bounding box.                            var common_g = svg.selectAll("#" + this.getAttribute("parent")).select( function() {                              if(this.getAttribute("use") === "container") {                                  return this;                              }                              else {                                  return null;                              }                                                          });                                                        common_g = D3Helper.getElFromSel(common_g);                            gr_type = common_g.getAttribute("type");                                                        //find the 4 corners of the bounding box                            var gr_left = D3Helper.getTransformX(common_g);                            var gr_right = gr_left + D3Helper.getWidth(gr_type, common_g);                            var gr_up = D3Helper.getTransformY(common_g);                            var gr_down = gr_up + D3Helper.getHeight(gr_type, common_g);                                                                                                                  if ( al_left + move_x < gr_left || al_right + move_x > gr_right || al_up + move_y < gr_up || al_down + move_y > gr_down) {                                                              if(hovering) {                                                                          //move the alien object to the right of the group                                    if(al_right + move_x > gr_right) {                                         move_x = (gr_right - al_left) + 20;                                     }                                                                          //move the alien object to the left of the group                                    else if(al_left + move_x < gr_left) {                                         move_x = (gr_left - al_right) - 20;                                     }                                      //move the alien object to the top of the current object                                    if(al_up + move_y < gr_up) {                                         move_y = (gr_up - al_down) - 20;                                     }                                                                          //move the alien object to the bottom of the current object                                    else if(al_down + move_y > gr_down) {                                        move_y = (gr_down - al_up) + 20;                                     }                                                                          //never move diagonally...only move the way the causes the least amount of movement                                    if ( Math.abs(move_y) >= Math.abs(move_x) && move_x !== 0) {                                        move_y = 0;                                    }                                                                          else if ( Math.abs(move_x) >= Math.abs(move_y) && move_y !== 0) {                                        move_x = 0;                                    }                                                                            //move the container negative distance instead                                    svg.selectAll("#" + this.id)                                       .attr("transform", function(d) {                                           return "translate(" + (D3Helper.getTransformX(this) + move_x) + "," + (D3Helper.getTransformY(this) + move_y) + ")";                                           });                                                                                   //move the children of the group accordingly                                    GroupHierarchy.moveAllChildren(this, move_x, move_y, svg);                                             //recurse...handle collisions for the object that just moved                                    CollisionHandling.handleCollisions(this, svg, false);                                    }                                  else {                                        //move the container negative distance instead                                    svg.selectAll("#" + container.id)                                       .attr("transform", function(d) {                                           return "translate(" + (D3Helper.getTransformX(this) - move_x) + "," + (D3Helper.getTransformY(this) - move_y) + ")";                                           });                                                                                   //move the children of the group accordingly                                    GroupHierarchy.moveAllChildren(container, (move_x * -1), (move_y * -1), svg);                                             //recurse...handle collisions for the object that just moved                                    CollisionHandling.handleCollisions(container, svg);                                  }                                                            }                                                        else {                                  //move the alien object according to the distances found                                svg.selectAll("#" + this.id)                                   .attr("transform", function(d) {                                       return "translate(" + (D3Helper.getTransformX(this) + move_x) + "," + (D3Helper.getTransformY(this) + move_y) + ")";                                       });                                                                           //move the children of the group accordingly                                GroupHierarchy.moveAllChildren(this, move_x, move_y, svg);                                         //recurse...handle collisions for the object that just moved                                CollisionHandling.handleCollisions(this, svg);                            }                                                        return;                        }                    if (GroupHierarchy.isDescendant(this, container, svg)) {                        return;                    }                                                              //don't handle collisions inside of a group                       if (container.getAttribute("parent") === this.id ) {                                             return;                    }                                                                //don't handle collisions for annotations                    if(type === "annotation") {                        return;                    }                      //move the alien object according to the distances found                    svg.selectAll("#" + this.id)                       .attr("transform", function(d) {                           return "translate(" + (D3Helper.getTransformX(this) + move_x) + "," + (D3Helper.getTransformY(this) + move_y) + ")";                           });                                                   //move the children of the group accordingly                    GroupHierarchy.moveAllChildren(this, move_x, move_y, svg);                             //recurse...handle collisions for the object that just moved                    CollisionHandling.handleCollisions(this, svg);                                        return this;                }                                  //if there were no collisions                else {                                        if(this.getAttribute("parent") === container.id) {                        d3.select(this)                            .attr("parent", "none");                                            }                                      //take the current object out of any group it was just in                    if(container.getAttribute("parent") === this.id) {                                            d3.select(container)                            .attr("parent", "none");                        return null;                    }                                    return null;                }            });                        //private functions:::                                                return;                    }, //end of handleCollisions                collided:function(el1, el2){            var my_left = D3Helper.getTransformX(el1);            var my_right = my_left + D3Helper.getWidth("container", el1);            var my_up = D3Helper.getTransformY(el1);            var my_down = my_up + D3Helper.getHeight("container", el1);                        var al_left = D3Helper.getTransformX(el2);            var al_right = al_left + D3Helper.getWidth("container", el2);            var al_up = D3Helper.getTransformY(el2);            var al_down = al_up + D3Helper.getHeight("container", el2);                    //checks for a collision on the right side of the current object                var col_rightSide = (al_left >= my_left && al_left <= my_right);                                  //checks for a collision on the left side of the current object                var col_leftSide = (al_right > my_left && al_right < my_right);                                  //checks for a collision where the current object is inside the alien horizontally                var col_horizBig = (al_left < my_left && al_right > my_right);                                  //checks for a collision where the alien is inside the current object horizontally                var col_horizSmall = (my_left < al_left && my_right > al_right);                                  //checks for a collision on the upper half of the current object                var col_upSide = (al_down >= my_up && al_down <= my_down);                                    //checks for a collision on the lower half of the current object                var col_downSide = (al_up > my_up && al_up < my_down);                                  //checks for a collision where the alien is inside the current object vertically                var col_vertBig = (al_up < my_up && al_down > my_down);                                  //checks for a collision where the alien is inside the current object vertically                var col_vertSmall = (my_up < al_up && my_down > al_down);                        if( ( (col_rightSide) || (col_leftSide) || (col_horizBig) ) && ( (col_upSide) || (col_downSide) || (col_vertBig) ) ){                return true;            }            else {                return false;            }                    },                getCollisions:function(element) {              //find the 4 corners of the bounding box            var my_left = D3Helper.getTransformX(element);            var my_right = my_left + D3Helper.getWidth(type, element);            var my_up = D3Helper.getTransformY(element);            var my_down = my_up + D3Helper.getHeight(type, element);                          //find all objects which lie inside the 4 corners            var aliens = svg.selectAll(".foreground")                .select(function(d) {                                    if(this.getAttribute("use") === "container" && this.getAttribute("id") !== container.getAttribute("id")) {                        return this;                    }                    else {                        return null;                    }                 });                             var collisions = aliens.select(function(d){                            var al_type = this.getAttribute("type");                                      //get the alien's 4 corners                                var al_left = D3Helper.getTransformX(this);                var al_right = al_left + D3Helper.getWidth(al_type, this);                var al_up = D3Helper.getTransformY(this);                var al_down = al_up + D3Helper.getHeight(al_type, this);                              //checks for a collision on the right side of the current object                var col_rightSide = (al_left >= my_left && al_left <= my_right);                                  //checks for a collision on the left side of the current object                var col_leftSide = (al_right > my_left && al_right < my_right);                                  //checks for a collision where the current object is inside the alien horizontally                var col_horizBig = (al_left < my_left && al_right > my_right);                                  //checks for a collision where the alien is inside the current object horizontally                var col_horizSmall = (my_left < al_left && my_right > al_right);                                  //checks for a collision on the upper half of the current object                var col_upSide = (al_down >= my_up && al_down <= my_down);                                    //checks for a collision on the lower half of the current object                var col_downSide = (al_up > my_up && al_up < my_down);                                  //checks for a collision where the alien is inside the current object vertically                var col_vertBig = (al_up < my_up && al_down > my_down);                                  //checks for a collision where the alien is inside the current object vertically                var col_vertSmall = (my_up < al_up && my_down > al_down);                                                       if( ( (col_rightSide) || (col_leftSide) || (col_horizBig) ) && ( (col_upSide) || (col_downSide) || (col_vertBig) ) ){                    return this;                }                else{                    return null;                }            });                        return collisions;                } //end of getCollisions            }    })